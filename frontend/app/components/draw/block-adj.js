import Ember from 'ember';

const { inject: { service } } = Ember;

import PathData from './path-data';

import AxisEvents from '../../utils/draw/axis-events';
import { stacks } from '../../utils/stacks';
import { selectAxis, blockAdjKeyFn, blockAdjEltId, foregroundSelector, selectBlockAdj } from '../../utils/draw/stacksAxes';

/* global d3 */

/*----------------------------------------------------------------------------*/

/** Used for CSS selectors targeting <g> and <path>-s generated by this component. */
const className = "blockAdj";

/*----------------------------------------------------------------------------*/

/**
 * @param blockAdj  [blockId0, blockId1]
 */
export default Ember.Component.extend(Ember.Evented, {
  store: service(),

  needs: ['component:draw/path-data'],

  blockAdj : Ember.computed('blockAdjId', function () {
    let
      blockAdjId = this.get('blockAdjId'),
    record = this.get('store').createRecord('blockAdj', {
      blockId0 : blockAdjId[0],
      blockId1 : blockAdjId[1]
    });
    console.log('blockAdjId', blockAdjId, blockAdjId[0], blockAdjId[1], record);
    // record.set('blockId0', blockAdjId[0]);
    // record.set('blockId1', blockAdjId[1]);
    return record;
  }),

  paths : Ember.computed('blockAdj.blockId0', 'blockAdj.blockId1', function () {
    console.log(this, 'paths blockAdj', this.get('blockAdj'),
                this.get('blockAdj.blockId0'), this.get('blockAdj.blockId1'));
    /** if no other processing required here, this could be simply Ember.computed.alias('blockAdj.paths').property('blockAdj.blockId0', 'blockAdj.blockId1') */
    let
    paths = this.get('blockAdj.paths');
    paths.then( (pathsValue) =>
      this.draw(pathsValue)
    );
    return paths;
  }),

  didRender() {
    this.drawGroup();
  },

  /** Render the <g.direct_progress> which contains the <g> and <path>
   * rendered by this component. */
  drawGroup() {
    let foreground = d3.selectAll(foregroundSelector);
    let pS = foreground.selectAll('g > g.direct_progress')
      .data([1])
      .enter()
      .append('g')
      .attr('class', 'direct_progress')
    ;
    console.log('drawGroup', pS.nodes(), pS.node());

    /* render the <g> for this block-adj */
    let
      blockAdjId = this.get('blockAdjId');

    let groupAddedClass = 'block-adj';
    let gS = pS.selectAll("g." + className + '.' + groupAddedClass);
    /* could use .data(), given a list of all block adjacencies :
     * .data(flowsService.blockAdjs, blockAdjKeyFn); ... gS.enter() ... */
    if (gS.empty()) {
      let gA = pS
        .append('g')
        .datum(blockAdjId)
        .attr('id', blockAdjEltId)
        .attr('class', className + ' ' + groupAddedClass)
      ;
    console.log(gA.nodes(), gA.node());
    }
  },

  /**
   * @param paths grouped by features
   */
  draw (featurePaths) {
    /** blockAdjId is also contained in the result featurePaths
     */
    let
      blockAdjId = this.get('blockAdjId');

    if (featurePaths[0].alignment.length) {
      const reversed = true;
      let a = featurePaths[0].alignment,
      ok = (a[0].blockId === blockAdjId[0+reversed]) && (a[1].blockId === blockAdjId[1-reversed]);
      if (! ok)
        console.log('draw verify', blockAdjId, a);
    }

    // let axisApi = this.get('drawMap.oa.axisApi');

    let axis = stacks.axes[blockAdjId[0]];
    let aS = selectAxis(axis);
    console.log(aS.node());

    let dpS = d3.selectAll(foregroundSelector + '> g.direct_progress');

    let baS = selectBlockAdj(dpS, blockAdjId);
    console.log(baS.nodes(), baS.node());
    
    if (baS.empty())
      console.log('draw', blockAdjId);
    else
    {
      /** groupAddedClass might be a classification of the feature, e.g. whether it is in a selection or group. */
      let groupAddedClass = featurePaths[0]._id.name;
      let gS = baS.selectAll("g." + className + '.' + groupAddedClass)
        .data(featurePaths, featurePathKeyFn);
      gS.exit().remove();

      let gA = gS.enter()
        .append('g')
        .attr('id', function (featurePath) { 
          let a = featurePath.alignment,
          id = [a[0].blockId, a[1].blockId];
          return blockAdjEltId(id);}) 
        .attr('class', className + ' ' + groupAddedClass)
      ;


      console.log('PathData', PathData);
      let gSA = gS.merge(gA),
      owner = Ember.getOwner(this),
      pS = gSA
        .selectAll("path." + className)
        .data(pathsOfFeature(owner), locationPairKeyFn),
      pSE = pS.enter()
        .append("path")
        .attr("class", className)
      ;
      pSE
        .attr("d", function(d) { return d.get('pathU'); });
      // setupMouseHover(pSE);

    }

  }
  
});

if (false) {
  /** Example of param paths passed to draw() above. */
  const examplePaths = 
[{"_id":{"name":"myMarkerC"},
  "alignment":[
      {"blockId":"5c75d4f8792ccb326827daa2","repeats":{
	  "_id":{"name":"myMarkerC","blockId":"5c75d4f8792ccb326827daa2"},
	  "features":[{"_id":"5c75d4f8792ccb326827daa6","name":"myMarkerC","value":[3.1,3.1],"blockId":"5c75d4f8792ccb326827daa2","parentId":null}],"count":1}},
      {"blockId":"5c75d4f8792ccb326827daa1","repeats":{
	  "_id":{"name":"myMarkerC","blockId":"5c75d4f8792ccb326827daa1"},
	      "features":[{"_id":"5c75d4f8792ccb326827daa5","name":"myMarkerC","value":[0,0],"blockId":"5c75d4f8792ccb326827daa1","parentId":null}],"count":1}}]}];
}


/*----------------------------------------------------------------------------*/


function featurePathKeyFn (featureBlock)
{ return featureBlock._id.name; }

/** This will later generate the cross-product feature.alignment[0].repeats X feature.alignment[1].repeats.
 * Currently just returns the first pair.
 * @param feature 1 element of the result array passed to draw()
 * @return [PathData, ...]
 */
function pathsOfFeature(owner) {
  const PathData = owner.factoryFor('component:draw/path-data');
  return function (feature) {
  let pair =
    PathData.create({
      feature0 : feature.alignment[0].repeats.features[0],
      feature1 : feature.alignment[1].repeats.features[0],
      block0 : feature.alignment[0].blockId,
      block1 : feature.alignment[1].blockId
    });
  console.log('PathData.create()', PathData, pair);
    return [pair];
  };
}

function locationPairKeyFn(locationPair)
{
  return locationPair.feature0._id + '_' + locationPair.feature1._id;
}

/*----------------------------------------------------------------------------*/
